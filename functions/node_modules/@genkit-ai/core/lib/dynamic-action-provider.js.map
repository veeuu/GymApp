{"version":3,"sources":["../src/dynamic-action-provider.ts"],"sourcesContent":["/**\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type * as z from 'zod';\nimport { Action, ActionMetadata, defineAction } from './action.js';\nimport { ActionType, Registry } from './registry.js';\n\ntype DapValue = {\n  [K in ActionType]?: Action<z.ZodTypeAny, z.ZodTypeAny, z.ZodTypeAny>[];\n};\n\nclass SimpleCache {\n  private value: DapValue | undefined;\n  private expiresAt: number | undefined;\n  private ttlMillis: number;\n  private dap: DynamicActionProviderAction;\n  private dapFn: DapFn;\n  private fetchPromise: Promise<DapValue> | null = null;\n\n  constructor(\n    dap: DynamicActionProviderAction,\n    config: DapConfig,\n    dapFn: DapFn\n  ) {\n    this.dap = dap;\n    this.dapFn = dapFn;\n    this.ttlMillis = !config.cacheConfig?.ttlMillis\n      ? 3 * 1000\n      : config.cacheConfig?.ttlMillis;\n  }\n\n  async getOrFetch(): Promise<DapValue> {\n    const isStale =\n      !this.value ||\n      !this.expiresAt ||\n      this.ttlMillis < 0 ||\n      Date.now() > this.expiresAt;\n    if (!isStale) {\n      return this.value!;\n    }\n\n    if (!this.fetchPromise) {\n      this.fetchPromise = (async () => {\n        try {\n          // Get a new value\n          this.value = await this.dapFn(); // this returns the actual actions\n          this.expiresAt = Date.now() + this.ttlMillis;\n\n          // Also run the action\n          this.dap.run(this.value); // This returns metadata and shows up in dev UI\n\n          return this.value;\n        } catch (error) {\n          console.error('Error fetching Dynamic Action Provider value:', error);\n          this.invalidate();\n          throw error; // Rethrow to reject the fetchPromise\n        } finally {\n          // Allow new fetches after this one completes or fails.\n          this.fetchPromise = null;\n        }\n      })();\n    }\n    return await this.fetchPromise;\n  }\n\n  invalidate() {\n    this.value = undefined;\n  }\n}\n\nexport interface DynamicRegistry {\n  __cache: SimpleCache;\n  invalidateCache(): void;\n  getAction(\n    actionType: string,\n    actionName: string\n  ): Promise<Action<z.ZodTypeAny, z.ZodTypeAny, z.ZodTypeAny> | undefined>;\n  listActionMetadata(\n    actionType: string,\n    actionName: string\n  ): Promise<ActionMetadata[]>;\n}\n\nexport type DynamicActionProviderAction = Action<\n  z.ZodTypeAny,\n  z.ZodTypeAny,\n  z.ZodTypeAny\n> &\n  DynamicRegistry & {\n    __action: {\n      metadata: {\n        type: 'dynamic-action-provider';\n      };\n    };\n  };\n\nexport function isDynamicActionProvider(\n  obj: Action<z.ZodTypeAny, z.ZodTypeAny>\n): obj is DynamicActionProviderAction {\n  return obj.__action?.metadata?.type == 'dynamic-action-provider';\n}\n\nexport interface DapConfig {\n  name: string;\n  description?: string;\n  cacheConfig?: {\n    // Negative = no caching\n    // Zero or undefined = default (3000 milliseconds)\n    // Positive number = how many milliseconds the cache is valid for\n    ttlMillis: number | undefined;\n  };\n  metadata?: Record<string, any>;\n}\n\nexport type DapFn = () => Promise<DapValue>;\nexport type DapMetadata = {\n  [K in ActionType]?: ActionMetadata[];\n};\n\nfunction transformDapValue(value: DapValue): DapMetadata {\n  const metadata: DapMetadata = {};\n  for (const key of Object.keys(value)) {\n    metadata[key] = value[key].map((a) => {\n      return a.__action;\n    });\n  }\n  return metadata;\n}\n\nexport function defineDynamicActionProvider(\n  registry: Registry,\n  config: DapConfig | string,\n  fn: DapFn\n): DynamicActionProviderAction {\n  let cfg: DapConfig;\n  if (typeof config == 'string') {\n    cfg = { name: config };\n  } else {\n    cfg = { ...config };\n  }\n  const a = defineAction(\n    registry,\n    {\n      ...cfg,\n      actionType: 'dynamic-action-provider',\n      metadata: { ...(cfg.metadata || {}), type: 'dynamic-action-provider' },\n    },\n    async (i, _options) => {\n      // The actions are retrieved and saved in a cache and then passed in here.\n      // We run this action to return the metadata for the actions only.\n      // We pass the actions in here to prevent duplicate calls to the mcp\n      // and also so we are guaranteed the same actions since there is only a\n      // single call to mcp client/host.\n      return transformDapValue(i);\n    }\n  );\n  implementDap(a as DynamicActionProviderAction, cfg, fn);\n  return a as DynamicActionProviderAction;\n}\n\nfunction implementDap(\n  dap: DynamicActionProviderAction,\n  config: DapConfig,\n  dapFn: DapFn\n) {\n  dap.__cache = new SimpleCache(dap, config, dapFn);\n  dap.invalidateCache = () => {\n    dap.__cache.invalidate();\n  };\n\n  dap.getAction = async (actionType: string, actionName: string) => {\n    const result = await dap.__cache.getOrFetch();\n    if (result[actionType]) {\n      return result[actionType].find((t) => t.__action.name == actionName);\n    }\n    return undefined;\n  };\n\n  dap.listActionMetadata = async (actionType: string, actionName: string) => {\n    const result = await dap.__cache.getOrFetch();\n    if (!result[actionType]) {\n      return [];\n    }\n\n    // Match everything in the actionType\n    const metadata = result[actionType].map((a) => a.__action);\n    if (actionName == '*') {\n      return metadata;\n    }\n\n    // Prefix matching\n    if (actionName.endsWith('*')) {\n      const prefix = actionName.slice(0, -1);\n      return metadata.filter((m) => m.name.startsWith(prefix));\n    }\n\n    // Single match or empty array\n    return metadata.filter((m) => m.name == actionName);\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA,oBAAqD;AAOrD,MAAM,YAAY;AAAA,EACR;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,eAAyC;AAAA,EAEjD,YACE,KACA,QACA,OACA;AACA,SAAK,MAAM;AACX,SAAK,QAAQ;AACb,SAAK,YAAY,CAAC,OAAO,aAAa,YAClC,IAAI,MACJ,OAAO,aAAa;AAAA,EAC1B;AAAA,EAEA,MAAM,aAAgC;AACpC,UAAM,UACJ,CAAC,KAAK,SACN,CAAC,KAAK,aACN,KAAK,YAAY,KACjB,KAAK,IAAI,IAAI,KAAK;AACpB,QAAI,CAAC,SAAS;AACZ,aAAO,KAAK;AAAA,IACd;AAEA,QAAI,CAAC,KAAK,cAAc;AACtB,WAAK,gBAAgB,YAAY;AAC/B,YAAI;AAEF,eAAK,QAAQ,MAAM,KAAK,MAAM;AAC9B,eAAK,YAAY,KAAK,IAAI,IAAI,KAAK;AAGnC,eAAK,IAAI,IAAI,KAAK,KAAK;AAEvB,iBAAO,KAAK;AAAA,QACd,SAAS,OAAO;AACd,kBAAQ,MAAM,iDAAiD,KAAK;AACpE,eAAK,WAAW;AAChB,gBAAM;AAAA,QACR,UAAE;AAEA,eAAK,eAAe;AAAA,QACtB;AAAA,MACF,GAAG;AAAA,IACL;AACA,WAAO,MAAM,KAAK;AAAA,EACpB;AAAA,EAEA,aAAa;AACX,SAAK,QAAQ;AAAA,EACf;AACF;AA4BO,SAAS,wBACd,KACoC;AACpC,SAAO,IAAI,UAAU,UAAU,QAAQ;AACzC;AAmBA,SAAS,kBAAkB,OAA8B;AACvD,QAAM,WAAwB,CAAC;AAC/B,aAAW,OAAO,OAAO,KAAK,KAAK,GAAG;AACpC,aAAS,GAAG,IAAI,MAAM,GAAG,EAAE,IAAI,CAAC,MAAM;AACpC,aAAO,EAAE;AAAA,IACX,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAEO,SAAS,4BACd,UACA,QACA,IAC6B;AAC7B,MAAI;AACJ,MAAI,OAAO,UAAU,UAAU;AAC7B,UAAM,EAAE,MAAM,OAAO;AAAA,EACvB,OAAO;AACL,UAAM,EAAE,GAAG,OAAO;AAAA,EACpB;AACA,QAAM,QAAI;AAAA,IACR;AAAA,IACA;AAAA,MACE,GAAG;AAAA,MACH,YAAY;AAAA,MACZ,UAAU,EAAE,GAAI,IAAI,YAAY,CAAC,GAAI,MAAM,0BAA0B;AAAA,IACvE;AAAA,IACA,OAAO,GAAG,aAAa;AAMrB,aAAO,kBAAkB,CAAC;AAAA,IAC5B;AAAA,EACF;AACA,eAAa,GAAkC,KAAK,EAAE;AACtD,SAAO;AACT;AAEA,SAAS,aACP,KACA,QACA,OACA;AACA,MAAI,UAAU,IAAI,YAAY,KAAK,QAAQ,KAAK;AAChD,MAAI,kBAAkB,MAAM;AAC1B,QAAI,QAAQ,WAAW;AAAA,EACzB;AAEA,MAAI,YAAY,OAAO,YAAoB,eAAuB;AAChE,UAAM,SAAS,MAAM,IAAI,QAAQ,WAAW;AAC5C,QAAI,OAAO,UAAU,GAAG;AACtB,aAAO,OAAO,UAAU,EAAE,KAAK,CAAC,MAAM,EAAE,SAAS,QAAQ,UAAU;AAAA,IACrE;AACA,WAAO;AAAA,EACT;AAEA,MAAI,qBAAqB,OAAO,YAAoB,eAAuB;AACzE,UAAM,SAAS,MAAM,IAAI,QAAQ,WAAW;AAC5C,QAAI,CAAC,OAAO,UAAU,GAAG;AACvB,aAAO,CAAC;AAAA,IACV;AAGA,UAAM,WAAW,OAAO,UAAU,EAAE,IAAI,CAAC,MAAM,EAAE,QAAQ;AACzD,QAAI,cAAc,KAAK;AACrB,aAAO;AAAA,IACT;AAGA,QAAI,WAAW,SAAS,GAAG,GAAG;AAC5B,YAAM,SAAS,WAAW,MAAM,GAAG,EAAE;AACrC,aAAO,SAAS,OAAO,CAAC,MAAM,EAAE,KAAK,WAAW,MAAM,CAAC;AAAA,IACzD;AAGA,WAAO,SAAS,OAAO,CAAC,MAAM,EAAE,QAAQ,UAAU;AAAA,EACpD;AACF;","names":[]}